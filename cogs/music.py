import asyncio
import discord
import settings
import youtube_dl

from discord.ext import commands
from cogs.helpers import handle_bad_entry, helpers
from dotenv import dotenv_values
from os import listdir, path
from sys import platform

config = dotenv_values("../.env")
FFMPEG_OPTIONS = {'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
                  'options': '-vn',
                  'executable': path.join(settings.EXECUTABLE_FOLDER, "ffmpeg.exe") if platform == "win32" \
                      else path.join(settings.EXECUTABLE_FOLDER, "ffmpeg")}
YDL_OPTIONS = {'format': "bestaudio"}


class music(commands.Cog):
    def __init__(self, client):
        self.client = client
        self.song_queue = []
        self.current_song = ""
        self.loop_queue = False
        self.lazy_play_list_processing = False
        self.static_queue = []

    @classmethod
    def fetch_audio_source(cls, sound_bite: str):
        audio_source = None
        ffmpeg_path = path.join(settings.EXECUTABLE_FOLDER, "ffmpeg.exe") if platform == "win32" \
            else path.join(settings.EXECUTABLE_FOLDER, "ffmpeg")
        try:
            audio_source = discord.FFmpegPCMAudio(
                executable=ffmpeg_path,
                source=path.join(settings.SOUND_EFFECTS_FOLDER, sound_bite))
        except Exception as e:
            # Just print to log why stuff failed.
            settings.LOGGER.exception(e)
        return audio_source

    @classmethod
    async def get_youtube_audio(cls, song_url: str):
        """
        Get the audio file generated by FFMPEG executable

        :param song_url: Youtube url of the song to process
        :return: tuple of (audio file, song name, url used by ffmpeg executable for streaming)
        """
        with youtube_dl.YoutubeDL(YDL_OPTIONS) as ydl:
            info = ydl.extract_info(song_url, download=False)
            ffmpeg_url = info['formats'][0]['url']
            song_name = info['title']

            audio_source = await discord.FFmpegOpusAudio.from_probe(ffmpeg_url, **FFMPEG_OPTIONS)
            return audio_source, song_name, ffmpeg_url

    @commands.command()
    async def join(self, ctx):
        if ctx.author.voice is None:
            await ctx.send("Get into a voice channel first..")

        voice_channel = ctx.author.voice.channel
        self.client.current_channel = voice_channel
        bot_current_voice_channel = discord.utils.get(ctx.bot.voice_clients, guild=ctx.guild)

        if not bot_current_voice_channel:
            if ctx.voice_client is None:
                vc = await voice_channel.connect()
            else:
                await ctx.voice_client.move_to(voice_channel)
                vc = ctx.voice_client

            audio_source = music.fetch_audio_source(sound_bite='vine-boom.mp3')
            if not vc.is_playing():
                vc.play(audio_source, after=None)
        else:
            # already connected
            pass

    @commands.command(aliases=['playsb', 'sb'])
    async def play_sb(self, ctx, query):
        """Plays a selected sounds bite. If query doesn't match any know soundbites, will send list of available ones"""
        if ctx.author.voice is not None:
            await ctx.invoke(self.client.get_command('join'))

            guild = self.client.get_guild(ctx.author.guild.id)
            sounds_path = settings.SOUND_EFFECTS_FOLDER
            sound_files = [f for f in listdir(sounds_path) if path.isfile(path.join(sounds_path, f))]

            if query in sound_files:
                audio_source = music.fetch_audio_source(sound_bite=path.join(settings.SOUND_EFFECTS_FOLDER, query))
                voice_client = discord.utils.get(self.client.voice_clients, guild=guild)

                while voice_client.is_playing():
                    await asyncio.sleep(1)
                else:
                    voice_client.play(audio_source, after=None)
            else:
                msg = f"Don't know '{query}' sounds bite. \nType '>play_sb <sound_bite>', picking a soundbite from the list below.\n"
                msg += "Here are the available options:\n"
                msg += '\n'.join([str(sound_file) for sound_file in sound_files])
                await ctx.send(msg, delete_after=600)

            await asyncio.sleep(10)
            await ctx.message.delete()
        else:
            await handle_bad_entry(ctx=ctx)
            await ctx.message.channel.send(f"{ctx.message.author.mention} get into a voice channel first")

    @commands.command()
    async def resume(self, ctx):
        voice_client = discord.utils.get(self.client.voice_clients, guild=self.client.get_guild(ctx.author.guild.id))
        voice_client.resume()

    @commands.command()
    async def pause(self, ctx):
        voice_client = discord.utils.get(self.client.voice_clients, guild=self.client.get_guild(ctx.author.guild.id))
        voice_client.pause()

    @commands.command()
    async def stop(self, ctx):
        voice_client = discord.utils.get(self.client.voice_clients, guild=self.client.get_guild(ctx.author.guild.id))
        await voice_client.disconnect()

    @commands.command()
    async def skip(self, ctx):
        if self.song_queue is None:
            await ctx.channel.send("There's nothing in the queue to skip onto ya schmuck")
        else:
            try:
                voice_client = discord.utils.get(self.client.voice_clients,
                                                 guild=self.client.get_guild(ctx.author.guild.id))
                if voice_client.is_playing():
                    voice_client.stop()

            except Exception as e:
                await handle_bad_entry(ctx=ctx, exception=e)

    @commands.command()
    async def play(self, ctx, song_url=None):
        if settings.ALLOW_PLAY:
            if ctx.author.voice is not None:
                await ctx.invoke(self.client.get_command('join'))

            voice_client = discord.utils.get(self.client.voice_clients,
                                             guild=self.client.get_guild(ctx.author.guild.id))

            if song_url:
                audio_source, song_name, ffmpeg_url = await music.get_youtube_audio(song_url=song_url)
                self.static_queue.append((song_url, song_name))
                self.song_queue.append((audio_source, song_name))

            if voice_client.is_playing():
                pass
            else:
                audio_source, song_name = self.song_queue.pop(0)
                self.current_song = song_name
                await ctx.channel.send(f"Playing: {song_name}")
                voice_client.play(audio_source, after=lambda e: self.after_each_song(ctx=ctx))
                await asyncio.sleep(1)
        else:
            sent_msg = await ctx.channel.send(f"`play` command has been disabled")
            await helpers.add_reaction(message=sent_msg, reaction="wheelchair_sign")

    def after_each_song(self, ctx):
        # https://stackoverflow.com/a/51112848/4512359
        # *comes in*
        # *copy/pastes code to run an async function from non-async function*
        # *refuses to elaborate*
        # *commits*
        self.current_song = ""
        if self.song_queue:
            coroutine = self.play(ctx=ctx)
        elif self.loop_queue:
            pass
            # coroutine = self.loop(ctx=ctx)
        else:
            coroutine = ctx.channel.send(f"Playback finished")
        fut = asyncio.run_coroutine_threadsafe(coroutine, self.client.loop)
        fut.result()

    @commands.command(aliases=['show_q', 'showq', 'list_q', 'listq', 'list_queue', 'q'])
    async def show_queue(self, ctx):
        """Shows song queue and currently playing song (if any)"""
        current_song_identifier = "--->"

        if self.static_queue:
            all_songs = [s_tuple[1] for s_tuple in self.static_queue]
            full_queue_msg = ""
            for i, song_name in enumerate(all_songs):
                padding = current_song_identifier if song_name == self.current_song \
                    else " " * len(current_song_identifier)
                full_queue_msg += f"`{padding} {i + 1}. {song_name}`\n"
        else:
            full_queue_msg = "Queue is empty"
        await ctx.channel.send(full_queue_msg)

    @commands.command()
    async def loop(self, ctx):
        """Requeue all the songs in the self.static_queue"""
        settings.LOGGER.info("Loading current queue...")
        async with ctx.channel.typing():
            for song_url, song_name in self.static_queue:
                audio_source, song_name, ffmpeg_url = await music.get_youtube_audio(song_url=song_url)
                self.song_queue.append((audio_source, song_name))
                await self.play(ctx=ctx)

    @commands.command(aliases=['clear_q', 'cq'])
    async def clear_queue(self, ctx):
        """Clears all songs in current queue and stop the playback"""
        voice_client = discord.utils.get(self.client.voice_clients,
                                         guild=self.client.get_guild(ctx.author.guild.id))
        self.current_song = ""
        self.song_queue = []
        self.static_queue = []
        if voice_client.is_playing():
            voice_client.stop()
        await asyncio.sleep(2)

    @commands.command(aliases=['pl'])
    async def playlist(self, ctx, playlist_name):
        """Loads and plays a playlist `playlist_name` from setting.PLAYLISTS"""
        if playlist_name.lower() in settings.PLAYLISTS.keys():
            if playlist_name.lower() == "gachi":
                await helpers.add_reaction(message=ctx.message, reaction="cum_face")
                await helpers.add_reaction(message=ctx.message, reaction="aubergine")
                await helpers.add_reaction(message=ctx.message, reaction="rain")

            if ctx.author.voice is not None:
                await ctx.invoke(self.client.get_command('join'))
            await asyncio.sleep(3)

            await self.clear_queue(ctx)
            async with ctx.channel.typing():
                for song_url in settings.PLAYLISTS[playlist_name]:
                    settings.LOGGER.info(f"Queueing: {song_url}")
                    audio_source, song_name, ffmpeg_url = await music.get_youtube_audio(song_url=song_url)
                    self.static_queue.append((song_url, song_name))
                    self.song_queue.append((audio_source, song_name))

                    await self.play(ctx)

        else:
            msg = f"{ctx.message.author.mention} unknown playlist. Available playlists: \n "
            msg += "\n".join(settings.PLAYLISTS.keys()) + "\n"
            msg += "**Warning!** Loading a playlist will replace the current queue."
            await ctx.channel.send(msg)

    @commands.command(aliases=['drop', 'remove'])
    async def remove_song(self, ctx, song_index):
        """Removes song from queue specified by `song_index`"""
        try:
            song_index = int(song_index)
        except ValueError as ve:
            # the line below is an abomination to God. You can copy and paste emojis from the server, and apparently
            # PyCharm and Python are perfectly happy to work with it.
            # I don't know how I feel about this, but I'm pretty sure I don't like it
            await handle_bad_entry(ctx=ctx, exception=ve)

        try:
            del self.static_queue[song_index]
        except IndexError as ie:  # if they select an index outside the queue
            await handle_bad_entry(ctx=ctx, exception=ie)


def setup(client):
    client.add_cog(music(client))
